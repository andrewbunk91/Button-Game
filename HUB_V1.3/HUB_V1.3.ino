// ================== HUB_V1.3.ino ==================
// Transport: ESP-NOW (station mode)
// Board: ESP32-WROOM-32
//
// Based on the HUB_V16 registration/reset workflow with added LED sequence control.
// Manages a Simon-style sequence game where the hub lights exactly one button at a time,
// advancing only after the correct button reports a press. Incorrect presses lock the round
// until a physical reset. When every button in the sequence has scored, the hub broadcasts
// a 2-second LED celebration and waits for the reset button before starting again.
// HUB_V1.3 removes the TFT display dependencies from HUB_V1.2, relying solely on Serial logs.
// ======================================================

#include <esp_now.h>
#include <WiFi.h>
#include <esp_idf_version.h>
#include <cstdio>

// === FIX: ResetEvent === Forward declaration prevents Arduino's autogenerated
// prototypes from referencing ResetEvent before its definition.
enum ResetEvent : uint8_t;

// === NEW FEATURE: dynamic hub MAC === Capture the hub's own MAC so we can
// announce it on demand instead of hardcoding it into the buttons.
static uint8_t hubMac[6] = {0};
static const uint8_t HUB_BROADCAST_ADDR[6] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};

// ---------- printScreen Helper ----------
void printScreen(const String &msg, bool newline = true) {
  Serial.print(msg);
  if (newline) Serial.println();
}

// === NEW FEATURE: dynamic hub MAC === Refresh the cached MAC address for this
// hub whenever we are about to share it with buttons.
static void refreshHubMac() {
  WiFi.macAddress(hubMac);
}

String formatMac(const uint8_t mac[6]) {
  char buf[18];
  snprintf(buf, sizeof(buf), "%02X:%02X:%02X:%02X:%02X:%02X",
           mac[0], mac[1], mac[2], mac[3], mac[4], mac[5]);
  return String(buf);
}

enum ResetEvent : uint8_t {
  RESET_EVENT_NONE = 0,
  RESET_EVENT_TAP  = 1,
  RESET_EVENT_HOLD = 2,
};

// ---------- Local feedback helper ----------
static inline void flashGreen(uint16_t ms = 30) {
  delay(ms);
}

// ===================================================
//                Wire Protocol (ESP-NOW)
// ===================================================

enum MsgKind : uint8_t {
  BTN_REGISTER    = 1,
  BTN_PRESS       = 2,
  HUB_LED_CONTROL = 100,
  HUB_FEEDBACK    = 101,
  HUB_ROUND_RESET = 102,
  HUB_ALL_FLASH   = 103,
  // === NEW FEATURE: dynamic hub MAC === Broadcast message so buttons can
  // discover the hub without hardcoded addresses.
  HUB_ANNOUNCE    = 200,
};

enum FeedbackCode : uint8_t {
  FDBK_INCORRECT     = 0,
  FDBK_CORRECT       = 1,
  FDBK_ALREADYCOUNT  = 2,
  FDBK_LOCKEDOUT     = 3,
};

typedef struct __attribute__((packed)) {
  uint8_t kind;
  uint8_t button_id;
  bool    ffa;
  uint8_t mac[6];
} btn_register_t;

typedef struct __attribute__((packed)) {
  uint8_t  kind;
  uint8_t  button_id;
  bool     pressed;
  uint16_t press_id;
  uint8_t  mac[6];
} btn_press_t;

typedef struct __attribute__((packed)) {
  uint8_t kind;
  uint8_t result;
} hub_feedback_t;

typedef struct __attribute__((packed)) {
  uint8_t kind;
} hub_round_reset_t;

typedef struct __attribute__((packed)) {
  uint8_t kind;       // HUB_LED_CONTROL
  bool    on;         // Desired LED state
  bool    suspend_rx; // Whether the button should suspend hub listening until it presses
} hub_led_control_t;

typedef struct __attribute__((packed)) {
  uint8_t  kind;   // HUB_ALL_FLASH
  uint8_t  times;  // Number of flash cycles
  uint16_t on_ms;  // Duration LEDs stay ON per cycle
  uint16_t off_ms; // Duration LEDs stay OFF per cycle
} hub_all_flash_t;

// === NEW FEATURE: dynamic hub MAC === Packet layout used when the hub
// announces its MAC so buttons can learn it dynamically.
typedef struct __attribute__((packed)) {
  uint8_t kind;  // HUB_ANNOUNCE
  uint8_t mac[6];
} hub_announce_t;

// ===================================================
//                Registration / Peers
// ===================================================

struct Peer {
  bool     present = false;
  uint8_t  mac[6]  = {0};
  uint8_t  button_id = 0;
  bool     ffa = false;
  bool     counted = false;
  uint16_t last_press_id = 0;
};

static const int MAX_PEERS = 16;
static Peer peers[MAX_PEERS];
static const uint8_t MAX_BUTTON_ID = 63;
int idToIndex[MAX_BUTTON_ID + 1];

int findPeerByMac(const uint8_t mac[6]) {
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) continue;
    if (memcmp(peers[i].mac, mac, 6) == 0) return i;
  }
  return -1;
}

int ensurePeerSlot(const uint8_t mac[6]) {
  int idx = findPeerByMac(mac);
  if (idx >= 0) return idx;
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) {
      peers[i].present = true;
      memcpy(peers[i].mac, mac, 6);
      peers[i].button_id = 0;
      peers[i].ffa = false;
      peers[i].counted = false;
      peers[i].last_press_id = 0;
      return i;
    }
  }
  return -1;
}

void clearPeers() {
  for (int i = 0; i < MAX_PEERS; i++) peers[i] = Peer{};
  for (int i = 0; i <= MAX_BUTTON_ID; i++) idToIndex[i] = -1;
}

void rebuildIdMap() {
  for (int i = 0; i <= MAX_BUTTON_ID; i++) idToIndex[i] = -1;
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) continue;
    if (peers[i].button_id > 0 && peers[i].button_id <= MAX_BUTTON_ID)
      idToIndex[peers[i].button_id] = i;
  }
}

int countPresent() {
  int n = 0;
  for (int i = 0; i < MAX_PEERS; i++) if (peers[i].present) n++;
  return n;
}

bool allFFA() {
  bool any = false;
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) continue;
    any = true;
    if (!peers[i].ffa) return false;
  }
  return any;
}

void resetRoundRuntime() {
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) continue;
    peers[i].counted = false;
  }
}

// ===================================================
//                 ESP-NOW helpers
// ===================================================

static esp_err_t sendTo(const uint8_t mac[6], const void* buf, size_t len) {
  return esp_now_send(mac, (const uint8_t*)buf, len);
}

void addEspNowPeerIfNeeded(const uint8_t mac[6]) {
  esp_now_peer_info_t p{};
  memcpy(p.peer_addr, mac, 6);
  p.channel = 0;
  p.encrypt = false;
  esp_now_add_peer(&p);
}

void sendLedControl(const uint8_t mac[6], bool on, bool suspendRx) {
  hub_led_control_t m{};
  m.kind = HUB_LED_CONTROL;
  m.on = on;
  m.suspend_rx = suspendRx;
  addEspNowPeerIfNeeded(mac);
  sendTo(mac, &m, sizeof(m));
}

void sendFeedback(const uint8_t mac[6], uint8_t code) {
  hub_feedback_t m{};
  m.kind = HUB_FEEDBACK;
  m.result = (uint8_t)code;
  addEspNowPeerIfNeeded(mac);
  sendTo(mac, &m, sizeof(m));
}

void broadcastRoundReset() {
  hub_round_reset_t m{};
  m.kind = HUB_ROUND_RESET;
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) continue;
    addEspNowPeerIfNeeded(peers[i].mac);
    sendTo(peers[i].mac, &m, sizeof(m));
  }
}

void sendAllFlash(uint8_t times = 5, uint16_t on_ms = 200, uint16_t off_ms = 200) {
  hub_all_flash_t m{};
  m.kind = HUB_ALL_FLASH;
  m.times = times;
  m.on_ms = on_ms;
  m.off_ms = off_ms;
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) continue;
    addEspNowPeerIfNeeded(peers[i].mac);
    sendTo(peers[i].mac, &m, sizeof(m));
  }
}

// === NEW FEATURE: dynamic hub MAC === Broadcast the hub's MAC address so
// buttons can discover it when the reset button is held.
void broadcastHubAnnouncement(uint8_t repeats = 5, uint16_t spacing_ms = 40) {
  refreshHubMac();
  hub_announce_t m{};
  m.kind = HUB_ANNOUNCE;
  memcpy(m.mac, hubMac, 6);
  String log = String("[Hub] Broadcasting HUB_ANNOUNCE with MAC ") + formatMac(hubMac);
  printScreen(log);
  for (uint8_t i = 0; i < repeats; i++) {
    esp_now_send(HUB_BROADCAST_ADDR, (const uint8_t*)&m, sizeof(m));
    delay(spacing_ms);
  }
}

void allLedsOff() {
  for (int i = 0; i < MAX_PEERS; i++) {
    if (!peers[i].present) continue;
    sendLedControl(peers[i].mac, false, false);
  }
}

void rebuildSequenceOrder() {
  rebuildIdMap();
  sequenceCount = 0;
  for (uint8_t id = 1; id <= MAX_BUTTON_ID; id++) {
    int idx = idToIndex[id];
    if (idx >= 0 && peers[idx].present) {
      sequenceOrder[sequenceCount++] = idx;
    }
  }
}

bool armSequenceIndex(int seqIndex) {
  if (seqIndex < 0 || seqIndex >= sequenceCount) return false;
  int peerIdx = sequenceOrder[seqIndex];
  if (peerIdx < 0 || !peers[peerIdx].present) return false;
  uint8_t buttonId = peers[peerIdx].button_id;
  String log = String("[Hub] Lighting button ID=") + String(buttonId);
  printScreen(log);
  sendLedControl(peers[peerIdx].mac, true, true);
  activeSequenceIndex = seqIndex;
  return true;
}

// ===================================================
//                    Game State
// ===================================================

enum GameMode : uint8_t { MODE_IDLE=0, MODE_SEQUENCE=1, MODE_FFA=2 };

GameMode mode = MODE_IDLE;
int participants = 0;
int counted = 0;

int sequenceOrder[MAX_PEERS];
int sequenceCount = 0;
int activeSequenceIndex = -1;

bool reg_open = false;
unsigned long reg_deadline_ms = 0;
const uint32_t REG_WINDOW_MS = 3000;

bool locked_out = false;

// CHANGE: Update pin mapping to actual reset button pin.
#define RESET_BUTTON_PIN 38
const bool RESET_ACTIVE_LOW = true;
const unsigned long RESET_DEBOUNCE_MS = 40;
const int RESET_PRESSED_LEVEL  = RESET_ACTIVE_LOW ? LOW  : HIGH;
const int RESET_RELEASED_LEVEL = RESET_ACTIVE_LOW ? HIGH : LOW;
int resetLastReading = RESET_RELEASED_LEVEL;
int resetStableState = RESET_RELEASED_LEVEL;
unsigned long resetLastDebounceMs = 0;
const unsigned long RESET_HOLD_THRESHOLD_MS = 1000;
bool resetPressActive = false;
bool resetHoldFired = false;
bool resetHoldActive = false;
unsigned long resetPressStartMs = 0;

void openRegistrationWindow() {
  reg_open = true;
  reg_deadline_ms = millis() + REG_WINDOW_MS;
  mode = MODE_IDLE;
  participants = 0;
  counted = 0;
  sequenceCount = 0;
  activeSequenceIndex = -1;
  locked_out = false;
  resetRoundRuntime();
  flashGreen(60);
  printScreen("[Hub] Registration window OPEN");
}

bool startRoundFromPeers() {
  reg_open = false;
  participants = countPresent();
  if (participants <= 0) {
    printScreen("[Hub] No participants; staying idle.");
    mode = MODE_IDLE;
    return false;
  }
  resetRoundRuntime();
  counted = 0;
  activeSequenceIndex = -1;
  sequenceCount = 0;
  locked_out = false;
  if (allFFA()) {
    mode = MODE_FFA;
    rebuildIdMap();
    printScreen("[Hub] Starting FFA with ", false);
    printScreen(String(participants), false);
    printScreen(" participants.");
  } else {
    mode = MODE_SEQUENCE;
    rebuildSequenceOrder();
    printScreen("[Hub] Starting SEQUENCE with ", false);
    printScreen(String(participants), false);
    printScreen(" participants.");
    if (sequenceCount == 0) {
      printScreen("[Hub] Warning: no sequence-capable buttons registered.");
      mode = MODE_IDLE;
      return false;
    }
  }
  broadcastRoundReset();
  delay(10);
  if (mode == MODE_FFA) {
    for (int i = 0; i < MAX_PEERS; i++) {
      if (!peers[i].present) continue;
      sendLedControl(peers[i].mac, true, false);
    }
  } else if (mode == MODE_SEQUENCE) {
    allLedsOff();
    if (!armSequenceIndex(0)) {
      printScreen("[Hub] Failed to arm first sequence button.");
      mode = MODE_IDLE;
      return false;
    }
  }
  return true;
}

void closeRegistrationAndStartRound() {
  if (!startRoundFromPeers()) openRegistrationWindow();
}

void finishRound() {
  printScreen("[Hub] Round complete. Awaiting reset...");
  sendAllFlash(5, 200, 200); // Approximately two seconds of flashing
  mode = MODE_IDLE;
  counted = 0;
  reg_open = false;
  locked_out = true;
  activeSequenceIndex = -1;
  sequenceCount = 0;
}

// ===================================================
// Reset button polling
// ===================================================

ResetEvent pollResetButton() {
  int reading = digitalRead(RESET_BUTTON_PIN);
  if (reading != resetLastReading) {
    resetLastDebounceMs = millis();
    resetLastReading = reading;
  }
  if ((millis() - resetLastDebounceMs) > RESET_DEBOUNCE_MS) {
    if (reading != resetStableState) {
      resetStableState = reading;
      if (resetStableState == RESET_PRESSED_LEVEL) {
        resetPressActive = true;
        resetHoldFired = false;
        resetHoldActive = false;
        resetPressStartMs = millis();
      } else {
        if (resetPressActive) {
          unsigned long heldMs = millis() - resetPressStartMs;
          bool firedHold = resetHoldFired;
          resetPressActive = false;
          resetHoldActive = false;
          resetHoldFired = false;
          if (!firedHold && heldMs < RESET_HOLD_THRESHOLD_MS)
            return RESET_EVENT_TAP;
        }
      }
    }
  }
  if (resetPressActive && !resetHoldFired) {
    if ((millis() - resetPressStartMs) >= RESET_HOLD_THRESHOLD_MS) {
      resetHoldFired = true;
      resetHoldActive = true;
      return RESET_EVENT_HOLD;
    }
  }
  return RESET_EVENT_NONE;
}

void handleShortResetPress() {
  printScreen("[Hub] Reset button tapped.");
  locked_out = false;
  counted = 0;
  resetRoundRuntime();
  activeSequenceIndex = -1;
  sequenceCount = 0;
  if (!startRoundFromPeers()) openRegistrationWindow();
}

void handleResetHold() {
  printScreen("[Hub] Reset button held; reopening registration.");
  // === NEW FEATURE: dynamic hub MAC === Share the hub MAC when the operator
  // performs a long hold so buttons can update their stored address.
  broadcastHubAnnouncement();
  locked_out = false;
  counted = 0;
  resetRoundRuntime();
  broadcastRoundReset();
  mode = MODE_IDLE;
  reg_open = true;
  reg_deadline_ms = millis() + REG_WINDOW_MS;
  participants = countPresent();
  sequenceCount = 0;
  activeSequenceIndex = -1;
  rebuildSequenceOrder();
}

// ===================================================
// ESP-NOW callbacks
// ===================================================

void onDataSent(const wifi_tx_info_t *info, esp_now_send_status_t status) { }

void onDataRecv(const esp_now_recv_info_t *info, const uint8_t *incomingData, int len) {
  if (len < 1) return;
  const uint8_t kind = incomingData[0];
  const uint8_t* src = info->src_addr;
  switch (kind) {
    case BTN_REGISTER: {
      if (len < (int)sizeof(btn_register_t)) return;
      const btn_register_t* m = (const btn_register_t*)incomingData;
      if (!reg_open && mode == MODE_IDLE) openRegistrationWindow();
      if (!reg_open) {
        printScreen("[Hub] Ignoring BTN_REGISTER (round in progress).");
        return;
      }
      int idx = ensurePeerSlot(src);
      if (idx < 0) {
        printScreen("[Hub] Peer table full; registration dropped.");
        return;
      }
      peers[idx].button_id = m->button_id;
      peers[idx].ffa = m->ffa;
      addEspNowPeerIfNeeded(src);
      String log = String("[Hub] REGISTER from ") + formatMac(src) + "  id=" + String(m->button_id) +
                   "  ffa=" + (m->ffa ? "YES" : "NO");
      printScreen(log);
      reg_deadline_ms = millis() + REG_WINDOW_MS;
      break;
    }

    case BTN_PRESS: {
      if (len < (int)sizeof(btn_press_t)) return;
      const btn_press_t* m = (const btn_press_t*)incomingData;
      if (!m->pressed) return;
      if (locked_out) {
        printScreen("[Hub] Press ignored (round complete, awaiting reset).");
        sendFeedback(src, FDBK_LOCKEDOUT);
        return;
      }
      if (mode == MODE_IDLE && !reg_open) {
        openRegistrationWindow();
        printScreen("[Hub] Press arrived; opened registration. Ignored until round starts.");
        return;
      }
      if (reg_open) {
        printScreen("[Hub] Press during registration; ignored.");
        return;
      }
      int idx = findPeerByMac(src);
      if (idx < 0 || !peers[idx].present) {
        printScreen("[Hub] Press from unknown MAC; ignored.");
        return;
      }
      if (m->press_id != 0 && m->press_id == peers[idx].last_press_id) return;
      peers[idx].last_press_id = m->press_id;
      if (mode == MODE_SEQUENCE) {
        if (activeSequenceIndex < 0 || activeSequenceIndex >= sequenceCount) {
          printScreen("[Hub] Sequence press but no active target.");
          sendFeedback(src, FDBK_INCORRECT);
          return;
        }
        int expectedPeerIdx = sequenceOrder[activeSequenceIndex];
        uint8_t expectedButtonId = peers[expectedPeerIdx].button_id;
        uint8_t id = m->button_id;
        printScreen("[Hub] SEQ press id=", false);
        printScreen(String(id), false);
        printScreen(" expected=", false);
        printScreen(String(expectedButtonId));
        if (idx == expectedPeerIdx && id == expectedButtonId) {
          sendFeedback(src, FDBK_CORRECT);
          sendLedControl(src, false, false);
          activeSequenceIndex++;
          if (activeSequenceIndex >= sequenceCount) {
            finishRound();
          } else {
            armSequenceIndex(activeSequenceIndex);
          }
        } else {
          sendFeedback(src, FDBK_INCORRECT);
          printScreen("[Hub] Incorrect press. Locking round until reset.");
          locked_out = true;
          allLedsOff();
        }
      } else if (mode == MODE_FFA) {
        printScreen("[Hub] FFA press from MAC ", false);
        printScreen(formatMac(src));
        if (!peers[idx].counted) {
          peers[idx].counted = true;
          counted++;
          sendFeedback(src, FDBK_CORRECT);
          sendLedControl(src, false, false);
          if (counted >= participants) finishRound();
        } else {
          sendFeedback(src, FDBK_ALREADYCOUNT);
          sendLedControl(src, false, false);
        }
      } else sendFeedback(src, FDBK_INCORRECT);
      break;
    }
    default: break;
  }
}

// ===================================================
// Setup / Loop
// ===================================================

void setup() {
  Serial.begin(115200);
  pinMode(RESET_BUTTON_PIN, INPUT_PULLUP);

  WiFi.mode(WIFI_STA);
  // === NEW FEATURE: dynamic hub MAC === Cache the station MAC so we can
  // announce it later on demand.
  refreshHubMac();
  if (esp_now_init() != ESP_OK) {
    printScreen("[Hub] ESP-NOW init failed");
    while (true) delay(1000);
  }
  esp_now_register_send_cb(onDataSent);
  esp_now_register_recv_cb(onDataRecv);
  clearPeers();
  openRegistrationWindow();
  printScreen("[Hub] Ready. Waiting for BTN_REGISTERs...");
}

void loop() {
  if (reg_open && (long)(millis() - reg_deadline_ms) >= 0)
    closeRegistrationAndStartRound();

  ResetEvent resetEvent = pollResetButton();
  if (resetEvent == RESET_EVENT_TAP) handleShortResetPress();
  else if (resetEvent == RESET_EVENT_HOLD) handleResetHold();

  if (resetHoldActive && reg_open)
    reg_deadline_ms = millis() + REG_WINDOW_MS;
}
